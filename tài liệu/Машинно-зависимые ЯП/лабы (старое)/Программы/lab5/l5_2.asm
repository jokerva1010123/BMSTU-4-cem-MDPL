;2.	Составить процедуру, проверяющую соответствие начала заданной последовательности символов синтаксической диаграмме бесскобочного выражения
;в процедуре для проверки, что очередной символ анализируемой последовательности является знаком операции, использовать таблицу их перекодирования,
;команду XLAT и одну команду сравнения.
;Процедура должна возвращать:
;	через регистр AX значение 0 при соответствии и через регистр SI – номер первого символа последовательности, на котором закончился анализ, 
;	значение 1 в AX, если первый символ не цифра и не знак минус,
;	значение 2 в AX, если превышено число операндов в выражении,  и через регистр SI – номер первого символа последовательности, на котором закончился анализ.
;	значение 3 в AX, если текст, предшествующий символу, на котором закончился анализ, не является арифметическим выражением.




Data	SEGMENT
	OpNum	EQU	6
	;таблица: ...* + , - . / 0..9 ...
	OpTab	DB 42 DUP (0)	;мусор
			DB 1,1,0,1,0,1	;арифметика
			DB 10 DUP (2)	;цифры
			DB 198 DUP (0)	;мусор
			   ;123456789
	;Expr1	DB '-1*2+3/4'	,'$'
	;Expr1	DB '+5*6+7-8'	,'$'
	;Expr1	DB '1-2/+3*'	,'$'
	Expr1	DB '1-2/c3'	,'$'
	;Expr1	DB '1+1+1+1+1+1+1+1'	,'$'
	Expr2	DB (?)
	sNewL	DB 13,10,'$'
	sAX		DB 'AX (result) == ','$'
	sSI		DB 'SI (number) == ','$'
Data	ENDS





Code	SEGMENT
	ASSUME CS:Code, DS:Data, SS:Stack

;------------------------------
;проверяет строку находящуюся в DX, длиной CX
;поочередно определяем, является символ мусором, цифрой или операцией
PR_CheckExpr	PROC	NEAR
;------------------------------
	;изначально - в ДХ лежит АДРЕС строки для анализа
	MOV		SI,DX		;адрес поместим в DI, потомучто его можно [разыменовывать]
	LEA		BX,OpTab	;в BX подготовим таблицу перекодировок в нули и единички
	MOV		AL,[SI]		;в АЛ засунем ЗНАЧЕНИЕ по АДРЕСУ строки (первый элемент)
	PUSH	AX			;сохраним этот элемент для проверки после перекодировки
	XLAT
	CMP		AL,2		;перекодировали, проверяем, первый символ - цифра?
	POP		AX
	JE		PRCE_SkipFirst ;если число то и замечательно, пошли отсюда
	;если же НЕ число
	CMP		AL,'-'		;восстановили, проверяем, первый символ - минус?
	JE		PRCE_SkipFirst ;если минус то всё прекрасно
		MOV		AX,1	;возвращаем в АХ 1 - первый символ не минус и не цифра
		SUB		SI,DX	;возвращаем в СИ номер символа строки, на котором закончили
		RET
	PRCE_SkipFirst:
	
	;определили что в первом символе, замечательно! теперь проходимся ПО ОСТАВШЕЙСЯ строке
	DEC		CX
	MOV		DI,0	;в ДИ будем хранить число найденных операндов
	PRCE_Loop:
		INC		SI
		MOV		AL,[SI]
		XLAT	;перекодировываем содержимое АЛ: мусор->0, операнд->1, цифра->2
		;проверяем символ на принадлежность, если он в группе цифр(2) - то не делаем ничего
		;если в группе операндов(1) - то проверяем, не достигнут ли предел
		;если в группе мусора(0) - то выходим из процедуры
		CMP		AL,1				
		JB		PRCE_CheckGarbage
		JE		PRCE_CheckOperand
			LOOP PRCE_Loop		;выполнится, если не <=, то есть >, то есть АЛ==2
				MOV		AX,0	;выполнится, если текущий символ - последний
				INC		SI		;для простоты понимания инкаем СИ, чтобы первый символ был №1 а не №0
				SUB		SI,DX
				RET
		PRCE_CheckGarbage:		;если мусор - то бежим отсюда
			MOV		AX,3
			INC		SI		;для простоты понимания
			SUB		SI,DX
			RET
		PRCE_CheckOperand:		;если операнд - смотрим не пора ли сбежать
			CMP		DI,OpNum
			JL		PRCE_SkipLimit ;если до этого операндов, операндов<максимума, то всё в порядке, иначе - выходим
				MOV		AX,2
				INC		SI		;для простоты понимания
				SUB		SI,DX
				RET
			PRCE_SkipLimit:
			INC		DI ;запоминаем что у нас стало на один операнд больше
		;MOV		AH,2	;	тестовая печать
		;MOV		DL,AL
		;ADD		DL,'0'
		;INT		21h
	LOOP PRCE_Loop
	;если дошли досюда - то последний символ является операндом
	;поэтому вернем в АХ 4
		MOV		AX,4
		INC		SI		;для простоты понимания
		SUB		SI,DX
	RET
PR_CheckExpr	ENDP
;------------------------------
	
	
START:
	MOV	AX,Data
	MOV	DS,AX

	;печать выражения
	MOV		AH,9
	LEA		DX,Expr1		;подготавливаем выражение 1
	INT		21h					;кастуем печать ^
	LEA		DX,sNewL		;подготавливаем перенос строки
	INT		21h
	
	LEA		DX,Expr1		;обрабатывать будем Ехпр1
	MOV		CX,OFFSET Expr2
	SUB		CX,DX			;в СХ получается длина Ехпр1
	DEC		CX				;дек - потому что ^ длина ВМЕСТЕ С ЗАКРЫВАЮЩИМ СИМВОЛОМ
	CALL	PR_CheckExpr	;вызываем проверку выражения в DX
	
	;печать значения АХ
	PUSH	AX
	LEA		DX,sAX
	MOV		AH,9
	INT		21h
	POP		AX
	MOV		AH,2
	MOV		DL,AL
	ADD		DL,'0'
	INT		21h
	MOV		AH,9
	LEA		DX,sNewL
	INT		21h
	;печать значения SI
	LEA		DX,sSI
	MOV		AH,9
	INT		21h	
	MOV		AH,2
	MOV		DX,SI
	MOV		DH,0
	ADD		DL,'0'
	INT		21h
	MOV		AH,9
	LEA		DX,sNewL
	INT		21h
	
	
	
	MOV		AL,0		;выход
	MOV		AH,4Ch
	INT		21h

Code	ENDS





Stack	SEGMENT STACK
	DW	128h DUP (?)
Stack	ENDS

	END START