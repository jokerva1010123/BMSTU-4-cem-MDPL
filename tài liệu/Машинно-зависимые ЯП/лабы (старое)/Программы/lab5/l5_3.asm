;3.b. Составить в соответствии с алгоритмом рекурсивную процедуру void TREE(int *U)
;выводящую значения полей Х узлов дерева. Узел дерева должен иметь поля типа WORD,
;представленные в подпрограмме симво-лическими именами :
;V – указатель на родителя (для корня дерева = 0),
;X – данные в узле: номер узла 0..9,A..Z и значение в узле 0..9,A..Z,
;L – указатель на левого наследника (для листа дерева = 0),
;R – указатель на правого наследника (для листа дерева = 0).
;	void tree(int* A)
;	{
;		printf(A+2) //печатаем текущее значение
;		if *(A+4) != 0 //если есть левая ветка
;			tree(A+4) //идем в левую ветку
;		if *(A+6) != 0 //и если есть правая ветка
;			tree(A+6) //то идем в правую ветку
;	}
;Для отладки программы дерево описать в начале сегмента данных (U0, U1,... представляют узлы) так:
Data	SEGMENT
	
		DB 	(?) 		;костыль, чтобы адрес U0 != 0
	U0	DW	 0,'07',U1,U2
	U1	DW	U0,'13',U3,U4
	U2	DW	U0,'29',U5,U6
	U3	DW	U1,'31',U7,U8
	U4	DW	U1,'45',U9,UA
	U5	DW	U2,'58', 0, 0
	U6	DW	U2,'6A', 0, 0
	U7	DW	U3,'70', 0, 0
	U8	DW	U3,'82', 0, UB
	U9	DW	U4,'94', 0, 0
	UA	DW	U4,'A6', 0, 0
	UB	DW	U8,'BB', 0, 0
	
	sData	DB	'Node data: ','$'
Data	ENDS


Code	SEGMENT
	ASSUME CS:Code, DS:Data, SS:Stack
	
;==========================================================
PR_ProcessBranch	PROC	NEAR
;-----------------------------
;процедура обрабатывает дерево, начиная с адреса узла, указанного в DX, уходя "вглубь"
;печатаются данные узла (номер и значение), если есть левая ветвь - то процедура вначале идет по ней
;-----------------------------
	CMP		DX,0
	JNE		PRPB_WORK ;если нам передали пустоту - ничего не делаем, сразу выпрыгиваем обратно
		RET
	PRPB_Work:
	
	PUSH	BX		;сохраняем значение ВХ
	MOV		BX,DX	;в ВХ будем хранить рабочий адрес, для печати и переадресации вглубь
	
	MOV		DX,[BX+4]			;в ДХ записываем ЗНАЧЕНИЕ ПО АДРЕСУ третьего элемента - адрес для перехода по левой ветке
	CALL	PR_ProcessBranch	;вызываем функцию для этого адреса
	
	;в ВХ лежит адрес узла
	MOV		AH,2			;печать символа
	MOV		DL,[BX+3]		;печатаем значение узла
	INT		21h
	MOV		DL,[BX+2]		;печатаем номер узла
	INT		21h
	MOV		DL,32			;\t
	INT		21h	
	MOV		DX,0			;восстанавливаем 0 в ДХ
	
	MOV		DX,[BX+6]
	CALL	PR_ProcessBranch	
	;если мы дошли до прохождения правой ветки, то у нас всё уже было напечатано, поэтому возвращаемся
	
	POP		BX ;функция кончилась - восстанавливаем значение ВХ
	RET
PR_ProcessBranch	ENDP
;==========================================================



START:
	MOV		AX,Data
	MOV		DS,AX
	
	LEA		DX,DS:U0			;заносим в ДХ адрес корня дерева
	CALL	PR_ProcessBranch	;POEKHALI!
	
	MOV		AL,0
	MOV		AH,4Ch
	INT		21h
Code	ENDS


Stack	SEGMENT STACK
	DW	128h DUP (?)
Stack	ENDS

	END START