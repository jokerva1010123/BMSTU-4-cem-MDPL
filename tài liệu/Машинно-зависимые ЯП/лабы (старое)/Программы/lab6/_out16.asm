PUBLIC	PR_Out16
EXTRN	PR_NewLine:NEAR






Code	SEGMENT	PUBLIC
	ASSUME CS:Code
;--------------------------------------------------------------------------------------
;Печатает переменную, переданную через стек, как шестнадцатиричное число без знака (15 как F, -15 как FFF1)
;--------------------------------------------------------------------------------------
PR_Out16	PROC	NEAR
	PUSH	BP		;передаем параметр
	MOV		BP,SP
	PUSH	AX		;используем для деления
	PUSH	DX
	PUSH	BX
	
	MOV		AX,[BP+4]	;получаем в АХ число, которое надо распечатать
	MOV		BX,16		;делить будем на 16; BX целиком чтобы возникало деление двойного слова (и не возникало переполнения)
	
	;а теперь, алгоритм следующий: предположим в АХ лежит шестнадцатеричное A1C, тогда вначале мы выделим место под это число,
	;то есть > ___ , а потом будем печатать со сдвигом влево: > __C , > _1C , > A1C
	PUSH	AX	;сохраним АХ, потому что нам его два раза печатать

	LO16_Div1:
		MOV		DX,0
		DIV		BX
		PUSH	AX			;сохраним значение AX (целая часть)
			MOV		AH,2	;печатаем пропуск
			MOV		DL,'a'
			INT		21h
		POP		AX		
		CMP		AX,0
	JNE		LO16_Div1
	
	MOV	AH,2
	MOV DL,8	;делаем один откат назад
	INT 21h
	
	POP		AX
	LO16_Div2:
		MOV		DX,0
		DIV		BX
		PUSH	AX			;сохраним значение AX (целая часть)
			MOV		AH,2
			CMP		DL,9
			JA		LO16_AddA
				ADD		DL,'0'	;печатаем значение DX (остаток)
				JMP		LO16_Add0
			LO16_AddA:
				ADD		DL,'A'
				SUB		DL,10
			LO16_Add0:
			INT		21h
			MOV		DL,8	;смещаемся назад ДВАЖДЫ
			INT		21h
			INT		21h
		POP		AX
		CMP		AX,0
	JNE		LO16_Div2
	
	
	POP		BX
	POP		DX
	POP		AX
	POP		BP
	RET

	RET
PR_Out16	ENDP
;--------------------------------------------------------------------------------------
Code	ENDS

END