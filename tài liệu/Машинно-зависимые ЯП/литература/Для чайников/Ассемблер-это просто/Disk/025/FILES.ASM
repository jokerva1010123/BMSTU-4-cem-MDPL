; ==== FILES.ASM - процедуры работы с файлами ====

; === Читаем файлы в текущем каталоге ===
Get_files proc
      push es
      mov es,Seg_files

      call Get_first  ;Получаем первый файл
      jc No_morefiles ;Если нет файлов вообще - на выход

      cmp word ptr es:[2Ch],002Eh ;Первый файл - '.'?
      je Next_file    ;Если так, то ищем следующий файл...

      call Move_file  ;Если нет, то переносим файл в память.

Next_file:
      call Get_other  ;Получаем следующий файл...
      jc No_morefiles ;Файлы закончились - на выход.

      call Move_file  ;Если нет, то переносим файл в память.
      jmp short Next_file ;Ищем следующий файл...

No_morefiles:
      pop es
      ret

All_files db '*.*',0
;DTA equ 80h <--- он нам больше не нужен!
Seg_files dw ? ;Сегментный адрес буфера файлов
Current_offset dw 500
Get_files endp

; === Поиск первого файла в текущем каталоге ===
Get_first proc
;Здесь можно поставить инструкцию int 3 и в процессе отладки позволить
;отладчику выполнить программу до конца (Run). Дойдя до int 3 отладчик
;обязательно остановится, что позволит вам проанализировать работу
;приведенных ниже строк. Попробуйте!

;     int 3        ;<=== Как точка останова для отладчика (BreakPoint)

      mov ax,714Eh ;Функция поиска первого файла
      xor di,di ;DI должен указывать на буфер, куда будут записываться
      xor si,si ;данные о найденном файле (типа DTA). SI пока остается тайной!
      mov cx,0FFh ;Ищем все возможные файлы. Это что-то вроде атрибутов файла
      mov dx,offset All_files ;Маска поиска
      int 21h
      mov Handle,ax ;Сохраним номер процесса поиска файлов для 714Fh
      ret
Get_first endp

; === Поиск следующих файлов ===
Get_other proc
      mov bx,Handle ;Указываем номер процесса.
      mov ax,714Fh  ;Функция поиска следующих файлов
      xor si,si
      xor di,di     ;DI должен указывать на буфер, куда будут записываться
      int 21h       ;данные о найденном файле (типа DTA).
      ret
Get_other endp

; --- Перенос имени найденного файла в сегмент файлов нашей программы ---
Move_file proc
;Рекомендую здесь также установить точку останова, как показано выше 
      push ds
      mov di,Current_offset ;Текущее свободное смещение
      mov ds,Seg_files
      mov si,2Ch     ;SI=имя найденного файла

Next_fbyte:
      lodsb          ;Получаем первый символ имени файла
      stosb          ;Сохраним символ в памяти
      or al,al       ;Это нуль (конец имени)?
      jnz Next_fbyte ;Следующий символ...

;Заносим размер файла
      mov si,1Ch     ;По этому смещению будет размер файла (4 слова)
      lodsd
      stosd
      lodsd
      stosd

      pop ds
      mov Current_offset,di ;Сохраним текущее смещение
      xor al,al
      stosb          ;Запишем еще один нуль...
      ret

;Итак, в буфер, на который указывает DI перед вызовом
;714Eh и 714Fh, заносятся:
;* По смещению 2Ch - имя найденного файла
;* По смещению 1Ch - размер файла (4 слова = 8 байт)
;* А также многое другое. Рассмотрим позже...
Move_file endp

; === Вывод наденных файлов на экран ===
Out_files proc
      mov bl,Number_files  ;BL указывает на количество выводимых файлов
      push ds
      push es
      push 0B800h
      pop es

      mov si,Start_file ;SI = начальную позицию при выводе на экран
      mov ah,1Bh        ;Атрибуты
      mov dx,0302h      ;Начало для вывода файлов
      mov ds,Seg_files  ;DS=сегмент найденных файлов в памяти

Next_fileout:
      call Print_string ;Выводим очередной файл

      call Print_fsize

      add si,8
      cmp byte ptr [si],0 ;Следующий байт=0? Значит, это был последный файл...
      jz Exit_files       ;Тогда выходим.

      add dx,0100h ;Иначе увеличиваем DH на 1 для вывода следующего имени...
      dec bl       ;Уменьшаем количество выводимых файлов на 1
      jnz short Next_fileout ;Уже 0? Тогда больше выводить не нужно...

Exit_files:
      pop es
      pop ds
      ret

Number_files db 21 ;Количество выводимых файлов на экран.
Start_file dw 500  ;Адрес (смещение) стартового файла для вывода на экран
                   ;Первые 500 байт отводятся для функций 714Eh и 714Fh, куда
                   ;они будут помещать информацию о найденном файле.
                   ;Что-то вроде DTA, только "посовременней"...
Out_files endp

; === Выводим размер файла ===
Print_fsize proc
      pusha
      push ds

      mov eax,ds:[si]   ;Получим первую часть размера файла
      mov ebx,ds:[si+4] ;Получим вторую часть

      push cs
      pop ds

;Обратите внимание, что переменная Number_dec - 64-х разрядная, а регистр
;EAX - 32-х. Для того, чтобы загрузить переменную полностью понадобится
;два раза занести EAX (или EBX и т.п.)!
      mov si,offset Number_dec ;Занесем размер файла в переменную Number_dec
      mov dword ptr [si],ebx   ;Процедура Out_dec будет выводить число,
      mov dword ptr [si+4],eax ;которое находится именно в этой переменной.

      mov dl,50        ;DL указывает на колонку
      mov ah,1Bh       ;AH содержит атрибуты для выводимого числа
      call Out_dec     ;Выводим число

      pop ds
      popa
      ret
Print_fsize endp