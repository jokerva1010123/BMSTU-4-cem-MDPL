EXTRN NUMBER: WORD

PUBLIC SIGNBINNUMBER
PUBLIC UNSIGNHEXNUMBER
PUBLIC SIGNFORHEX
PUBLIC DECTOUHEX
PUBLIC DECTOSBIN

; Сегмент данных
DATAS SEGMENT PARA PUBLIC 'DATA'
	LIMIT2 DW 1
	LIMIT16 DW 15
	SIGNBINNUMBER DB 16 DUP('0'), '$'
	UNSIGNHEXNUMBER DB 4 DUP('0'), '$'
	SIGNFORHEX DB ' '
DATAS ENDS

; Сегмент кода
CODES SEGMENT PARA PUBLIC 'CODE'	
    ASSUME CS:CODES, DS:DATAS
	
DECTOUHEX PROC NEAR
	MOV AX, NUMBER		; из памяти беру число
	MOV BX, 3			; столько раз мы будем делать так называемый цикл, так как в 16сс только 4 знака  (а индексация с 0)))))
	DIGIT:
		MOV DX, AX		; чтобы взять из числа 4 бита
		AND DX, LIMIT16	; как раз только их и оставляю, все остальное в 0
		CMP DL, 10		; сравниваю с 10, если больше, то надо прибавить 7 к коду, чтобы получить нормальную букву
		JB GETDIGIT		; ну а если меньше 10, то идем сразу рабоать с кодом (CF == 1)
		ADD DL, 7 		; так как из букв в 16 сс надо получить буквы в ascii, поэтому просто сделать + 30 как у чисел нельзя, и мы делаем + 7 и + 30
		GETDIGIT:
			ADD DL, '0'	; добавляю 30 к коду
			MOV UNSIGNHEXNUMBER[BX], DL ; заносим наше число полученное (то есть код числа в память для вывода)
			MOV CL, 4	; ну не работает SAR, если туда сразу написать 4
			SAR AX, CL  ; сдвиг на 4 бита вправо, чтобы получить след цифру\букву...
			DEC BX		; уменьшаем BХ на 1
			CMP BX, -1	; Почему не через СХ, потому что не работает, поэтому если BX == -1, то конец... 
			JNE DIGIT	; как раз если флаг ZF == 0
	RET
	;SAR ;Команда sar используется для арифметического сдвига разрядов операнда вправо. Команду sar можно использовать для деления целочисленных операндов со знаком на степени 2.
	;AND ;Команда and используется для логического умножения двух операндов. Результат операции помещается по адресу первого операнда.
DECTOUHEX ENDP

DECTOSBIN PROC NEAR
	; сначла выясняю, превышает ли оно знаковое или нет, типа максимум 32767 в знаковом
	; а у меня может быть 65535, поэтому... делаю проверку, и есть больше 
	; то обратный код пишу, и при этом знак минус сдавлю, как символ того, что это обратный код
	MOV CL, ' '  		; знак для вывода
	MOV SIGNFORHEX, CL	; заношу в знак
	MOV AX, NUMBER		; переносим число из памяти в AX
	CMP AX, 32767		; сравниваю с серединой, то есть выясняю, нуден ли обратынй код
	JBE LITTLENUM		; если меньше, то по метке, если больше, то команды ниже
	MOV CL, '-' 		; меняю знак
	MOV SIGNFORHEX, CL	; заношу в память
	SUB AX, 1			; отнимаю 1 от числа чтобы получить обратный код и знак
	NOT AX				; инверсия числа
	LITTLENUM:
		MOV BX, 15 		; максимум раз повторять для записи в память перевода числа
		GETBINDIGIT:	;
			MOV DX, AX	; заношу в DX число
			AND DX, LIMIT2	; веру один бит послдений из числа
			ADD DL, '0'		; прибавить 30 к коду бита нашего последнего
			MOV SIGNBINNUMBER[BX], DL 	; кладу бит в память
			MOV CL, 1	;  делаю сдвиг
			SAR AX, CL	; вот он сделался
			DEC BX		; уменьшаю BX (bx от 15 до 0, так как в asm литл эндиан)
			CMP BX, -1	; если равно bx -1, то 
			JNE GETBINDIGIT	; пока не равно, то есть bx > -1, то еще беру цифры
	RET		
DECTOSBIN ENDP

CODES ENDS
END